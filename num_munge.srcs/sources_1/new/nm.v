//
// Generated by Bluespec Compiler, version 2025.01 (build a798d8a9)
//
// On Wed Feb 19 21:58:22 PST 2025
//
//
// Ports:
// Name                         I/O  size props
// ARADDR                         O    32 const
// ARPROT                         O     3 const
// ARVALID                        O     1 const
// RREADY                         O     1 const
// AWADDR                         O    32 const
// AWPROT                         O     3 const
// AWVALID                        O     1
// WDATA                          O    32 const
// WSTRB                          O     4 const
// WVALID                         O     1
// BREADY                         O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ARREADY                        I     1 unused
// RDATA                          I    32 unused
// RRESP                          I     2 unused
// RVALID                         I     1 unused
// AWREADY                        I     1 reg
// WREADY                         I     1 reg
// BRESP                          I     2 unused
// BVALID                         I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module nm(CLK,
	  RST_N,

	  ARADDR,

	  ARPROT,

	  ARVALID,

	  ARREADY,

	  RREADY,

	  RDATA,

	  RRESP,

	  RVALID,

	  AWADDR,

	  AWPROT,

	  AWVALID,

	  AWREADY,

	  WDATA,

	  WSTRB,

	  WVALID,

	  WREADY,

	  BREADY,

	  BRESP,

	  BVALID);
  input  CLK;
  input  RST_N;

  // value method read_arADDR
  output [31 : 0] ARADDR;

  // value method read_arPROT
  output [2 : 0] ARPROT;

  // value method read_arVALID
  output ARVALID;

  // action method read_arREADY
  input  ARREADY;

  // value method read_rREADY
  output RREADY;

  // action method read_rDATA
  input  [31 : 0] RDATA;

  // action method read_rRESP
  input  [1 : 0] RRESP;

  // action method read_rVALID
  input  RVALID;

  // value method write_awADDR
  output [31 : 0] AWADDR;

  // value method write_awPROT
  output [2 : 0] AWPROT;

  // value method write_awVALID
  output AWVALID;

  // action method write_awREADY
  input  AWREADY;

  // value method write_wDATA
  output [31 : 0] WDATA;

  // value method write_wSTRB
  output [3 : 0] WSTRB;

  // value method write_wVALID
  output WVALID;

  // action method write_wREADY
  input  WREADY;

  // value method write_bREADY
  output BREADY;

  // action method write_bRESP
  input  [1 : 0] BRESP;

  // action method write_bVALID
  input  BVALID;

  // signals for module outputs
  wire [31 : 0] ARADDR, AWADDR, WDATA;
  wire [3 : 0] WSTRB;
  wire [2 : 0] ARPROT, AWPROT;
  wire ARVALID, AWVALID, BREADY, RREADY, WVALID;

  // register dma_awready
  reg dma_awready;
  wire dma_awready$D_IN, dma_awready$EN;

  // register dma_bvalid
  reg dma_bvalid;
  wire dma_bvalid$D_IN, dma_bvalid$EN;

  // register dma_state
  reg dma_state;
  wire dma_state$D_IN, dma_state$EN;

  // register dma_wready
  reg dma_wready;
  wire dma_wready$D_IN, dma_wready$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_dma_update_state,
       CAN_FIRE_read_arREADY,
       CAN_FIRE_read_rDATA,
       CAN_FIRE_read_rRESP,
       CAN_FIRE_read_rVALID,
       CAN_FIRE_write_awREADY,
       CAN_FIRE_write_bRESP,
       CAN_FIRE_write_bVALID,
       CAN_FIRE_write_wREADY,
       WILL_FIRE_RL_dma_update_state,
       WILL_FIRE_read_arREADY,
       WILL_FIRE_read_rDATA,
       WILL_FIRE_read_rRESP,
       WILL_FIRE_read_rVALID,
       WILL_FIRE_write_awREADY,
       WILL_FIRE_write_bRESP,
       WILL_FIRE_write_bVALID,
       WILL_FIRE_write_wREADY;

  // value method read_arADDR
  assign ARADDR = 32'd0 ;

  // value method read_arPROT
  assign ARPROT = 3'd0 ;

  // value method read_arVALID
  assign ARVALID = 1'd1 ;

  // action method read_arREADY
  assign CAN_FIRE_read_arREADY = 1'd1 ;
  assign WILL_FIRE_read_arREADY = 1'd1 ;

  // value method read_rREADY
  assign RREADY = 1'd1 ;

  // action method read_rDATA
  assign CAN_FIRE_read_rDATA = 1'd1 ;
  assign WILL_FIRE_read_rDATA = 1'd1 ;

  // action method read_rRESP
  assign CAN_FIRE_read_rRESP = 1'd1 ;
  assign WILL_FIRE_read_rRESP = 1'd1 ;

  // action method read_rVALID
  assign CAN_FIRE_read_rVALID = 1'd1 ;
  assign WILL_FIRE_read_rVALID = 1'd1 ;

  // value method write_awADDR
  assign AWADDR = 32'd0 ;

  // value method write_awPROT
  assign AWPROT = 3'd0 ;

  // value method write_awVALID
  assign AWVALID = !dma_state || !dma_awready ;

  // action method write_awREADY
  assign CAN_FIRE_write_awREADY = 1'd1 ;
  assign WILL_FIRE_write_awREADY = 1'd1 ;

  // value method write_wDATA
  assign WDATA = 32'hDEADBEEF ;

  // value method write_wSTRB
  assign WSTRB = 4'b1111 ;

  // value method write_wVALID
  assign WVALID = !dma_state || !dma_wready ;

  // action method write_wREADY
  assign CAN_FIRE_write_wREADY = 1'd1 ;
  assign WILL_FIRE_write_wREADY = 1'd1 ;

  // value method write_bREADY
  assign BREADY = dma_state && !dma_bvalid ;

  // action method write_bRESP
  assign CAN_FIRE_write_bRESP = 1'd1 ;
  assign WILL_FIRE_write_bRESP = 1'd1 ;

  // action method write_bVALID
  assign CAN_FIRE_write_bVALID = 1'd1 ;
  assign WILL_FIRE_write_bVALID = 1'd1 ;

  // rule RL_dma_update_state
  assign CAN_FIRE_RL_dma_update_state = 1'd1 ;
  assign WILL_FIRE_RL_dma_update_state = 1'd1 ;

  // register dma_awready
  assign dma_awready$D_IN = AWREADY ;
  assign dma_awready$EN = 1'd1 ;

  // register dma_bvalid
  assign dma_bvalid$D_IN = BVALID ;
  assign dma_bvalid$EN = 1'd1 ;

  // register dma_state
  assign dma_state$D_IN = 1'd1 ;
  assign dma_state$EN =
	     !dma_state || dma_awready && dma_wready && dma_bvalid ;

  // register dma_wready
  assign dma_wready$D_IN = WREADY ;
  assign dma_wready$EN = 1'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        dma_awready <= `BSV_ASSIGNMENT_DELAY 1'd0;
	dma_bvalid <= `BSV_ASSIGNMENT_DELAY 1'd0;
	dma_state <= `BSV_ASSIGNMENT_DELAY 1'd0;
	dma_wready <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (dma_awready$EN)
	  dma_awready <= `BSV_ASSIGNMENT_DELAY dma_awready$D_IN;
	if (dma_bvalid$EN)
	  dma_bvalid <= `BSV_ASSIGNMENT_DELAY dma_bvalid$D_IN;
	if (dma_state$EN) dma_state <= `BSV_ASSIGNMENT_DELAY dma_state$D_IN;
	if (dma_wready$EN)
	  dma_wready <= `BSV_ASSIGNMENT_DELAY dma_wready$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    dma_awready = 1'h0;
    dma_bvalid = 1'h0;
    dma_state = 1'h0;
    dma_wready = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // nm

